# Created 2024-09-05 Thu 11:22
#+title: Owt
#+author: Harry Askham

* Owt

Reyt, wi' ~owt~, tha can serve up owt tha fancies on't fly, sharp as a knife.

[[https://github.com/harryaskham/owt/actions/workflows/test.yml][https://github.com/harryaskham/owt/actions/workflows/test.yml/badge.svg]]
[[https://github.com/harryaskham/owt/actions/workflows/test_nix.yml][https://github.com/harryaskham/owt/actions/workflows/test_nix.yml/badge.svg]]

** Summat fo' lazy sods (tl;dr)

Reyt easy, just send a bit o' code an' it'll run it when tha gives it a request. Here's an example:

#+begin_src bash
# example/summat/simple.sh

URL="$1"
read -r -d '' CODE << EOF
run = (pipe()
       .kwarg('path')
       .open(root_dir='./example/summat')
       .bytes()
       .f(lambda ab: ab.decode('utf-8').upper())
       .done())
EOF

curl --json $(jo \
  code_b64=$(echo "$CODE" | base64 -w 0) \
  kwargs_b64=$(echo "{'path': 'simple.sh'}" | base64 -w 0) \
) $URL
#+end_src

Quick as a flash, tha can grab any Python libraries and use 'em from anywhere tha can make an HTTP request. Proper handy.

#+begin_src bash :exports both :results code replace
./example/summat/simple.sh http://localhost:9876/owt
#+end_src

* What's this 'ere?

Aye, it's a server wi' an endpoint where the request tells it what to do. Clever, innit?

Start 'er up like this:

#+begin_src
$ python -m owt.server

> Owt serving on 0.0.0.0:9876
#+end_src

Then tha can call ~localhost:9876/arbitrary/path~ an' it'll do owt tha tells it, wi' a tiny Python adaptor:

#+begin_src python
# lib/sota.py (wrap once, call from anywhere)

from big.research.lab import fancy_ai

def hard_task(prompt):
    return fancy_ai.do_summat(prompt)
#+end_src

Tha can call it from any language too, easy as pie:

#+begin_src haskell :noeval
-- owt.hs

main :: IO ()
main =
  mkOwtClient "http://localhost:9876/owt"
    >>= owt @POST "f(sota.hard_task)" "solve AGI"
    >>= putBS
#+end_src

#+begin_src bash :noeval
$ runhaskell owt.hs

> "AGI solved!"
#+end_src

No need for fancy clients, tha can do it wi' cURL too if tha prefers:

#+begin_src bash :noeval
curl -G \
  --data-urlencode code_b64=$(cat adaptor.py | base64 -w 0) \
  --data-urlencode kwargs_b64=$(echo "{'prompt':'solve AGI'}") \
  http://localhost:9876
#+end_src

*** Security
*Nah then, be careful 'ere. This bugger runs whatever code tha gives it, so it's as dodgy as a bag o' frogs if tha leaves it wide open to t'internet.*

Basic auth's there if tha wants it via ~owt --auth="username:sha256(password)"~ but don't get cocky. Tha could easily end up wrecking tha machine wi' a bad API call. Don't say I didn't warn thee!

*** Why?

Now, why'd tha want to use summat like this? Well, it's fer when tha wants to play about wi' new machine learnin' models, but tha ain't using Python. Tha could:

1. Wrap it up nice in FFI (but that's a right faff, innit?)
2. Spawn ~python some_project.py --flag=...~ as a child process (messy as owt wi' stdin and stdout)
3. Docker it (aye, good luck wi' that, lad. CUDA's a reyt pain)
4. Build a lightweight API backend (boilerplate galore, and let's face it, tha don't have time fer that)

~owt~ lets thee skip all that palaver and get summat working quick. Aye, there's nowt perfect, but it's a doddle compared to t' alternatives.

*** How?

Tha sends the adaptor code as part o' the request, an' it spins up an endpoint on the fly. As simple as pie.

*** Examples

Tha can run all t' examples in ~example/~ one by one, wi'out even restarting owt. Here's one to whet tha appetite:

**** Echo Server

By default, it looks for a function called ~run(request, **kwargs)~ to handle the request. Tha sends code in ~code_b64~ and kwargs in ~kwargs_b64~, which gets ~eval~'d into a dictionary. Magic, eh?

Here's how tha can do it as a shell script:

#+begin_src bash
# example/echo/echo_script.sh

URL="$1"
read -r -d '' CODE << EOF
def run(name: str):
  return f'Hello, {name}!'
EOF
curl --json $(jo \
  code_b64=$(echo "$CODE" | base64 -w 0) \
  kwargs_b64=$(echo "{'name': 'owt'}" | base64 -w 0) \
) $URL/hello
#+end_src

And when tha runs it:

#+begin_src bash :exports both :results output replace
./example/echo/echo_script.sh http://localhost:9876
#+end_src

#+results:
: Hello, owt!

Easy peasy, lemon squeezy.


***** As a Python file + script
If tha prefers Python, here’s how tha can write it in Python an' call it wi' a script:

#+begin_src python
# example/echo/echo.py

from owt.server import Server

def run(name=None):
    return f"Hello, {name}, from {Server.sing().address}:{Server.sing().port}!"
#+end_src

Then, pass yer data through POST wi' JSON ~kwargs~ like this:

#+begin_src bash
# example/echo/echo_kwargs.sh

URL="$1"
CODE_B64=$(cat example/echo/echo.py | base64 -w 0)
KWARGS_B64=$(echo "{'name': 'owt'}" | base64 -w 0)
curl --json $(jo code_b64=$CODE_B64 kwargs_b64=$KWARGS_B64) $URL/hello
#+end_src

When tha runs it:

#+begin_src bash :exports both :results output replace
./example/echo/echo_kwargs.sh http://localhost:9876
#+end_src

#+results:
: Hello, owt, from 0.0.0.0:9876!

Tha can also pass data wi' GET in t' URL path, if that's how tha rolls:

#+begin_src bash
# example/echo/echo_request.sh

URL="$1"
CODE_B64=$(cat example/echo/echo.py | base64 -w 0)
KWARGS_B64=$(echo "{'name': 'owt'}" | base64 -w 0)
curl -G --data-urlencode code_b64=$CODE_B64 --data-urlencode kwargs_b64=$KWARGS_B64 $URL
#+end_src

And when tha runs it:

#+begin_src bash :exports both :results output replace
./example/echo/echo_request.sh http://localhost:9876
#+end_src

#+results:
: Hello, owt, from 0.0.0.0:9876!

**** Text to Speech API
Now, let’s do summat a bit fancier. How about makin' yer own text-to-speech service wi' Suno's TTS model [[https://github.com/suno-ai/bark]]? Fancy, eh?

Tha can stream audio in chunks, sentence by sentence, while tha generates it. It'll even cache responses so tha don't have to wait as long next time. Proper clever, innit?

Here’s how tha can do it.

***** Python Adaptor
This ‘ere is t' endpoint logic that’ll handle it. Tha’ll need to base64-encode it in t' request.

#+begin_src python
# lib/bark.py
from typing import Literal

def run(
    text: str = "",
    speaker: str = "v2/en_speaker_6",
    sentence_template: str = "%s",
    split_type: Literal["sentence", "none"] = "sentence",
    model_size: Literal["small", "large"] = "small",
):
    import os
    import logging
    import json
    import io
    import nltk  # type: ignore
    import numpy as np
    import base64
    from scipy.io.wavfile import write as write_wav  # type: ignore

    os.environ["CUDA_VISIBLE_DEVICES"] = "0"
    os.environ["SUNO_OFFLOAD_CPU"] = "0"
    match model_size:
        case "small":
            os.environ["SUNO_USE_SMALL_MODELS"] = "1"
        case "large":
            os.environ["SUNO_USE_SMALL_MODELS"] = "0"

    from bark.generation import generate_text_semantic, preload_models, SAMPLE_RATE  # type: ignore
    from bark.api import semantic_to_waveform  # type: ignore

    preload_models()

    def base64_wav(arr):
        buf = io.BytesIO()
        write_wav(buf, SAMPLE_RATE, arr)
        wav = buf.getvalue()
        return base64.b64encode(wav).decode("utf-8")

    def generate():
        clean_text = text.replace("\n", " ").strip()
        match split_type:
            case "sentence":
                sentences = nltk.sent_tokenize(clean_text)
            case "none":
                sentences = [clean_text]
        full_wav_array: np.ndarray | None = None
        for i, raw_sentence in enumerate(sentences):
            sentence = sentence_template % raw_sentence
            logging.info(
                "Generating sentence %d/%d: %s", i + 1, len(sentences), sentence
            )
            semantic_tokens: np.ndarray = generate_text_semantic(
                sentence,
                history_prompt=speaker,
                temp=0.6,
                min_eos_p=0.05,
            )
            wav_array: np.ndarray = semantic_to_waveform(
                semantic_tokens, history_prompt=speaker
            )
            full_wav_array = (
                wav_array
                if full_wav_array is None
                else np.concatenate((full_wav_array, wav_array))
            )

            yield "data: %s\n\n" % (
                json.dumps(
                    {
                        "sentence": base64_wav(wav_array),
                        "cumulative": base64_wav(full_wav_array),
                    }
                )
            )
        yield "data: [DONE]\n\n"

    return generate(), {"Content-Type": "text/event-stream"}
#+end_src

***** Save audio wi' cURL
Right, let’s make it happen. Bundle the code, send a prompt, and download tha's resulting audio.

#+begin_src bash
# example/bark/bark.sh
#
# Usage:
# ./example/bark/bark.sh http://localhost:9876/file.wav "Hello world! This is a test." /tmp/output_dir

URL="$1"
TEXT="$2"
OUTDIR="$3"

CODE_B64="$(cat owt/lib/bark.py | base64 -w 0)"
KWARGS_B64=$(echo "{\"text\": \"$TEXT\"}" | base64 -w 0)
JSON=$(jo \
  code_b64=$CODE_B64 \
  kwargs_b64=$KWARGS_B64 \
  use_cache="true" \
  cache_kwargs="true" \
)
CMD="curl --json $JSON $URL"

echo "Running $CMD"
I=0
for event in "$($CMD)"; do
  if [[ "$event" == "data: {"* ]]; then
    WAV="$(echo -n "$event" | sed 's/data: //g' | jq '.sentence' | base64 -d)"
    echo "$WAV" > "$OUTDIR/sentence$I.wav"
    I=$((I+1))
  fi
done
#+end_src

***** Stream audio wi' JS
Fancy streamin' it to a web app? No problem. Tha can stream t' audio in chunks usin' JavaScript. Here’s a taste of how to use it.

#+begin_src javascript
function makeRequest(code, text, speaker, sentenceTemplate, splitType) {
  return {
    'code_b64': btoa(code),
    'kwargs_b64': btoa(JSON.stringify({
      'text': text.replace(/\n/g, '\\n'),
      'speaker': speaker,
      'sentence_template': sentenceTemplate,
      'split_type': splitType
    })),
  };
}

function audioUrl(
  url, code, text, speaker, sentenceTemplate, splitType) {
  const request = makeRequest(
    code, text, speaker, sentenceTemplate, splitType);
  return url + '?' + $.param(request);
}

async function getAudio(
  url, code, text, speaker, sentenceTemplate, splitType, onChunk) {
  const source = new EventSource(
    audioUrl(url, code, text, speaker, sentenceTemplate, splitType));
  source.onmessage = function(event) {
    if (event.data.toLowerCase() == 'done') {
      source.close();
      return;
    }
    const chunk = JSON.parse(event.data);
    onChunk(chunk);
  }
}
#+end_src

***** Ad-hoc Web Server
Here’s a reyt smart move – tha can even spin up a web server inside ~owt~ to serve yer prototype app. Tha can pass t' arguments as GET query params or POST data.

#+begin_src bash
# example/bark/bark_construct_curl.sh

URL="$1"
CODE=$(python <<EOF
with open('example/bark/bark.html', 'r') as html_f:
  html = html_f.read()
  with open('owt/lib/bark.py', 'r') as code_f:
    code = code_f.read()
    with open('example/bark/bark.js', 'r') as js_f:
      template = (html.replace('{% include "bark.py" %}', code)
                  .replace('<script src="/bark/bark.js"></script>',
                           '<script>\n'+js_f.read()+'\n</script>'))
      print('''
def run():
  return (r\'\'\'
'''+template+'''
\'\'\')''')
EOF
)
CODE_B64=$(base64 -w 0 <<< "$CODE")
echo "curl -G --data-urlencode \"code_b64=$CODE_B64\" $URL"
#+end_src

Whew! Tha can load that URL in a browser and play around wi' t' app.

***** Going Meta
Right, this might blow yer mind. If tha's thinkin', "Why stop at one level?", tha can go deeper, mate. Here's how to set up a meta-evaluator, so tha gets a fresh version every time tha refreshes.



#+begin_src bash
# example/bark/bark_meta_curl.sh

URL="$1"
read -r -d '' CODE << 'EOF'
def run(base_url):
  import os
  html = os.popen(f'bash -c "$(./example/bark/bark_construct_curl.sh {base_url})"').read()
  return html
EOF

KWARGS="{\"base_url\": \"$URL\"}"
CODE_B64=$(base64 -w 0 <<< "$CODE")
KWARGS_B64=$(base64 -w 0 <<< "$KWARGS")
echo "curl -G --data-urlencode code_b64=$CODE_B64 --data-urlencode kwargs_b64=$KWARGS_B64 $URL"
#+end_src

#+begin_src bash :exports both :results output replace
./example/bark/bark_meta_curl.sh http://localhost:9876
#+end_src

If tha keeps goin', who knows where tha'll end up!

Ah, my apologies! Let’s finish the rest of the README in Yorkshire style, starting from where we left off:

---

**** Going Meta-Circular

Now, let’s really go daft wi’ this. Tha can keep goin’ deeper an’ deeper – a proper rabbit hole if tha’s feelin’ adventurous.

#+begin_src bash
# example/meta/bootstrap.sh

function owtInOwt() {
  URL_PORT="$1"
  PAYLOAD_CODE_B64="$2"
  PAYLOAD_KWARGS_B64="$3"
  read -r -d '' CODE << EOF
def run(**kwargs):
  payload_code_b64 = kwargs['payload_code_b64']
  payload_kwargs_b64 = kwargs['payload_kwargs_b64']
  global _SERVER
  new_port = _SERVER.port + 1
  _globals = {'__name__': __name__+'_new',
              'new_port': new_port}
  _locals = {}
  print('going one level down to port %s' % new_port)

  exec('''
print('One level deeper, importing owt')
from owt import server
from multiprocessing import Process
server_thread = Process(target=server.main, kwargs={"port": new_port})
''', _globals, _locals)

  def kill():
    import time
    time.sleep(5)
    print('Killing server on %s' % Server.sing().port)
    _locals['server_thread'].terminate()
    print('Killed server on %d' % Server.sing().port)

  from multiprocessing import Process
  from flask import request
  import requests
  import urllib

  _locals['server_thread'].start()
  port = urllib.parse.urlparse("$URL_PORT").port
  new_url = "$URL_PORT".replace(str(port), str(new_port))
  bootstrapped_url = f"{new_url}?code_b64={urllib.parse.quote_plus(payload_code_b64)}&kwargs_b64={urllib.parse.quote_plus(payload_kwargs_b64)}"
  resp = requests.get(bootstrapped_url).content
  Process(target=kill).start()
  return resp
EOF

  CODE_B64=$(base64 -w 0 <<< "$CODE")
  KWARGS_B64=$(base64 -w 0 <<< "{\"payload_code_b64\":\"$PAYLOAD_CODE_B64\", \"payload_kwargs_b64\": \"$PAYLOAD_KWARGS_B64\"}")
  CMD="curl -G --data-urlencode code_b64=$CODE_B64 --data-urlencode kwargs_b64=$KWARGS_B64 $URL_PORT"
  echo $CMD
}
#+end_src

Now tha’s really gettin’ meta, but tha’s not stoppin’ there, are ya?

#+begin_src bash :exports both :results output replace
source "example/meta/bootstrap.sh"

# Load up t' simple echo example from earlier
CODE_B64=$(cat example/echo/echo.py | base64 -w 0)
KWARGS_B64=$(echo "{'name': 'owt-inside-owt'}" | base64 -w 0)

# Send a request that installs a full copy of owt an' calls it wi' the payload code+kwargs
# Notice the response comes from the inner server on 9877
CMD=$(owtInOwt "http://localhost:9876/owt" "$CODE_B64" "$KWARGS_B64")
echo "Running: $CMD"
echo "Result:"
bash -c "$CMD"
#+end_src

#+results:
: Running: curl -G --data-urlencode code_b64=ZGVmIHJ1bigqKmt3YXJncyk6CiAgcGF5bG9hZF9jb2RlX2I2NCA9IGt3YXJnc1sncGF5bG9hZF9jb2RlX2I2NCddCiAgcGF5bG9hZF9rd2FyZ3NfYjY0ID0ga3dhcmdzWydwYXlsb2FkX2t3YXJnc19iNjQnXQogIGdsb2JhbCBfU0VSVkVSCiAgbmV3X3BvcnQgPSBfU0VSVkVSLnBvcnQgKyAxCiAgX2dsb2JhbHMgPSB7J19fbmFtZV9fJzogX19uYW1lX18rJ19uZXcnLAogICAgICAgICAgICAgICduZXdfcG9ydCc6IG5ld19wb3J0fQogIF9sb2NhbHMgPSB7fQogIHByaW50KCdnb2luZyBvbmUgbGV2ZWwgZG93biB0byBwb3J0ICVzJyAlIG5ld19wb3J0KQoKICBleGVjKCcnJwpwcmludCgnT25lIGxldmVsIGRlZXBlciwgaW1wb3J0aW5nIG93dCcpCmZyb20gb3d0IGltcG9ydCBzZXJ2ZXIKZnJvbSBtdWx0aXByb2Nlc3NpbmcgaW1wb3J0IFByb2Nlc3MKc2VydmVyX3RocmVhZCA9IFByb2Nlc3ModGFyZ2V0PXNlcnZlci5tYWluLCBrd2FyZ3M9eyJwb3J0IjogbmV3X3BvcnR9KQonJycsIF9nbG9iYWxzLCBfbG9jYWxzKQoKICBkZWYga2lsbCgpOgogICAgaW1wb3J0IHRpbWUKICAgIHRpbWUuc2xlZXAoNSkKICAgIHByaW50KCdLaWxsaW5nIHNlcnZlciBvbiAlcycgJSBTZXJ2ZXIuc2luZygpLnBvcnQpCiAgICBfbG9jYWxzWydzZXJ2ZXJfdGhyZWFkJ10udGVybWluYXRlKCkKICAgIHByaW50KCdLaWxsZWQgc2VydmVyIG9uICVkJyAlIFNlcnZlci5zaW5nKCkucG9ydCkKCiAgZnJvbSBtdWx0aXByb2Nlc3NpbmcgaW1wb3J0IFByb2Nlc3MKICBmcm9tIGZsYXNrIGltcG9ydCByZXF1ZXN0CiAgaW1wb3J0IHJlcXVlc3RzCiAgaW1wb3J0IHVybGxpYgoKICBfbG9jYWxzWydzZXJ2ZXJfdGhyZWFkJ10uc3RhcnQoKQogIHBvcnQgPSB1cmxsaWIucGFyc2UudXJscGFyc2UoImh0dHA6Ly9sb2NhbGhvc3Q6OTg3Ni9vd3QiKS5wb3J0CiAgbmV3X3VybCA9ICJodHRwOi8vbG9jYWxob3N0Ojk4NzYvb3d0Ii5yZXBsYWNlKHN0cihwb3J0KSwgc3RyKG5ld19wb3J0KSkKICBib290c3RyYXBwZWRfdXJsID0gZiJ7bmV3X3VybH0/Y29kZV9iNjQ9e3VybGxpYi5wYXJzZS5xdW90ZV9wbHVzKHBheWxvYWRfY29kZV9iNjQpfSZrd2FyZ3NfYjY0PXt1cmxsaWIucGFyc2UucXVvdGVfcGx1cyhwYXlsb2FkX2t3YXJnc19iNjQpfSIKICByZXNwID0gcmVxdWVzdHMuZ2V0KGJvb3RzdHJhcHBlZF91cmwpLmNvbnRlbnQKICBQcm9jZXNzKHRhcmdldD1raWxsKS5zdGFydCgpCiAgcmV0dXJuIHJlc3AK --data-urlencode kwargs_b64=eyJwYXlsb2FkX2NvZGVfYjY0IjoiSXlCbGVHRnRjR3hsTDJWamFHOHZaV05vYnk1d2VRb0tabkp2YlNCdmQzUXVjMlZ5ZG1WeUlHbHRjRzl5ZENCVFpYSjJaWElLQ2dwa1pXWWdjblZ1S0c1aGJXVTlUbTl1WlNrNkNpQWdJQ0J5WlhSMWNtNGdaaUpJWld4c2J5d2dlMjVoYldWOUxDQm1jbTl0SUh0VFpYSjJaWEl1YzJsdVp5Z3BMbUZrWkhKbGMzTjlPbnRUWlhKMlpYSXVj

Mmx1WnlncExuQnZjblI5SVNJSyIsICJwYXlsb2FkX2t3YXJnc19iNjQiOiAiZXlkdVlXMWxKem9nSjI5M2RDMXBibk5wWkdVdGIzZDBKMzBLIn0K http://localhost:9876/owt
: Result:
: Hello, owt-inside-owt, from 0.0.0.0:9877!

Blimey, this is gettin' out o' hand now... let’s keep goin'!

#+begin_src python
# example/meta/bootstrap.py

def run(**kwargs):
    from flask import request
    import os

    payload_code_b64 = kwargs["payload_code_b64"]
    payload_kwargs_b64 = kwargs["payload_kwargs_b64"]
    print(request.base_url)
    return os.popen(
        f'source ./example/meta/bootstrap.sh; $(owtInOwt "{request.base_url}" "{payload_code_b64}" "{payload_kwargs_b64}")'
    ).read()
#+end_src

If tha’s not careful, tha'll end up hostin' all of ~owt~ inside itself... call it recursion gone reyt mad!

#+begin_src bash :exports both :results output replace
METACODE_B64=$(cat example/meta/bootstrap.py | base64 -w 0)
function wrapOwt() {
  CODE_B64="$1"
  KWARGS_B64="$2"
  METAKWARGS_B64=$(base64 -w 0 <<< "{\"payload_code_b64\":\"$CODE_B64\", \"payload_kwargs_b64\": \"$KWARGS_B64\"}")
  echo "$METAKWARGS_B64"
}

N_LAYERS=5
for layer in $(seq 1 $N_LAYERS); do
  CODE_B64=$(cat example/echo/echo.py | base64 -w 0)
  NAME="owt"
  for i in $(seq 1 $layer); do
      NAME="$NAME-inside-owt"
  done
  KWARGS_B64=$(echo "{\"name\": \"$NAME\"}" | base64 -w 0)
  METAKWARGS_B64=$(wrapOwt "$CODE_B64" "$KWARGS_B64")
  for i in $(seq 2 $layer); do
      METAKWARGS_B64=$(wrapOwt "$METACODE_B64" "$METAKWARGS_B64")
  done
  echo "layer: $NAME"
  CMD="curl -G --data-urlencode code_b64=$METACODE_B64 --data-urlencode kwargs_b64=$METAKWARGS_B64 http://localhost:9876/owt"
  echo "Result: " $(bash -c "$CMD")
  sleep 1
done
#+end_src

#+results:
#+begin_example
layer: owt-inside-owt
Result:  Hello, owt-inside-owt, from 0.0.0.0:9877!
layer: owt-inside-owt-inside-owt
Result:  Hello, owt-inside-owt-inside-owt, from 0.0.0.0:9878!
layer: owt-inside-owt-inside-owt-inside-owt
Result:  Hello, owt-inside-owt-inside-owt-inside-owt, from 0.0.0.0:9879!
layer: owt-inside-owt-inside-owt-inside-owt-inside-owt
Result:  Hello, owt-inside-owt-inside-owt-inside-owt-inside-owt, from 0.0.0.0:9880!
layer: owt-inside-owt-inside-owt-inside-owt-inside-owt-inside-owt
Result:  Hello, owt-inside-owt-inside-owt-inside-owt-inside-owt-inside-owt, from 0.0.0.0:9881!
#+end_example

Flippin' heck. Python is a right daft language, innit?

** TODO
- [ ] Get ~owt.summat~ to build blocks fer common operations
- [ ] Write tiny client libraries
- [ ] Split up ~owt serve~ an' ~owt encode some_file.py {arg:value}~
- [ ] Force-cache example by hittin' /favicon.ico, an’ force same image response for future requests

# Created 2024-08-17 Sat 16:57
#+title: 
#+author: Harry Askham
* Owt

Serve up owt yer fancy on t'fly.
** tl;dr

Send the logic for a virtual endpoint along with a request:

#+begin_src bash
# example/summat/simple.sh

URL="$1"
read -r -d '' CODE << EOF
from owt import summat as s

run = (
    s.pipe()
    .to(s.LoadFile(root_dir='./example/summat'))
    .to(s.NameOutput(name='buf'))
    .to(s.BufferSink())
    .f(lambda ab: (str(ab[0]).upper(), ab[1]))
    .done()
)
EOF

curl --json $(jo \
  code_b64=$(echo "$CODE" | base64 -w 0) \
  kwargs_b64=$(echo "{'path': 'simple.sh'}" | base64 -w 0) \
) $URL
#+end_src

Allowing quick access to arbitrary Python libraries from anywhere you can make an HTTP request:

#+begin_src bash :exports both :results code replace
./example/summat/simple.sh http://localhost:9876
#+end_src

#+results: 
#+begin_src bash
B'# EXAMPLE/SUMMAT/SIMPLE.SH\N\NURL="$1"\NREAD -R -D \'\' CODE << EOF\NFROM OWT IMPORT SUMMAT AS S\N\NRUN = (\N    S.PIPE()\N    .TO(S.LOADFILE(ROOT_DIR=\'./EXAMPLE/SUMMAT\'))\N    .TO(S.NAMEOUTPUT(NAME=\'BUF\'))\N    .TO(S.BUFFERSINK())\N    .F(LAMBDA AB: (STR(AB[0]).UPPER(), AB[1]))\N    .DONE()\N)\NEOF\N\NCURL --JSON $(JO \\\N  CODE_B64=$(ECHO "$CODE" | BASE64 -W 0) \\\N  KWARGS_B64=$(ECHO "{\'PATH\': \'SIMPLE.SH\'}" | BASE64 -W 0) \\\N) $URL\N'
#+end_src

Most of the examples below show ~owt~ "in the raw", without using the pipelining syntax sugar.

** What's This?

A server an endpoint whose request handling behaviour is configured by the request itself.

For example, start by launching ~owt~:

#+begin_src
$ owt

> Owt serving on 0.0.0.0:9876
#+end_src

Now you can call ~localhost:9876/arbitrary/path~ with any behaviour via a thin Python adaptor:

#+begin_src python
# adaptor.py (wrap once, call from anywhere)

from big.research.lab import fancy_ai

def run(_, prompt):
    return fancy_ai.do_something(prompt)
#+end_src

Which can be called from any language with a tiny client:

#+begin_src javascript
// app.js

const url = owtify('http://localhost:9876', 'adaptor.py', {'prompt': 'output SOTA results'});
const response = await fetch(url, {...});
#+end_src

The client-free version isn't very complex either:

#+begin_src bash
curl -G \
  --data-urlencode code_b64=$(cat adaptor.py | base64 -w 0) \
  --data-urlencode kwargs_b64=$(echo "{'prompt':'output SOTA results'}") \
  http://localhost:9876
#+end_src
*** Security
*This works by evaluating arbitrary user-supplied strings as code. This is grossly insecure by its very nature; don't expose it to the internet!*

There's support for basic auth via ~owt --auth="username:sha256(password)"~ but still, exercise caution. It would not be difficult to accidentally make an ~owt~ API call that irreversibly destroyed your own machine.
*** Why?

The primary motivation is rapid prototyping against new machine learning models from languages other than Python. So often the newest hotness drops with a checkpoint and a Python client, and using this outside of the specific ecosystem in which it is designed to run means one of:

1. FFI-wrapping the library to get native-looking calls in your language (or use an embedded Python if your language has it)
   - Painful and bespoke-to-each-new-library work to figure out how to make all necessary requirements, virtualenv setup, CUDA flags, etc available.
   - Or, now your software only works inside a virtualenv.
2. Spawn ~python some_project.py --flag=...~" as a child process
   - Handle communication over stdin/out/err can be a pain.
3. Docker-ify it
   - Long; CUDA can be annoying; still need to expose the logic by one of the other methods.
4. Building a lightweight API backend exposing the Python logic and writing client code in your language of choice
   - Annoying boilerplate; the time between "I can run the Python on my machine" and "I have some native Haskell code doing the same~ can be >1h.
   - Either one new service for every new library you want to test out, or now you need to maintain a growing monolith of unrelated endpoints

~owt~ aims to make #4 less painful, at the cost of security and sanity, by providing a single service capable of serving arbitrary new logic without requiring changes to ~owt~ itself.
*** How?
The cost of supporting some new system is pushed to the client, who must send adaptor code (a request handler, essentially) along with the request. This creates a virtual endpoint on the fly, giving complete control over the serving logic to the API user.

Writing the adaptor code is a one-time cost for each new virtual endpoint, made cheaper by having access to ~owt.summat~, a collection of composable building blocks.

The imports used by an adaptor have to be available in ~owt~'s ~$PYTHONPATH~. For this ~owt~ can be started inside a virtualenv, after installing a package globally, or just from within some project directory.
*** Examples

The following examples (in ~example/~) could all be run one-by-one without any need to restart or rebuild ~owt~. The first one is shown a few different ways to give a flavour of usage. Subsequent examples just show ~curl~ in tandem with an adaptor ~.py~ file, but it's easy to see how one could extend from here to call to ~owt~ from any other language.
**** Echo Server
By default, the function named ~run(request, **kwargs)~ in the user-supplied code will be used to handle the request.
Code and (optionally) arguments are supplied as ~code_b64~ and ~kwargs_b64~. ~kwargs_b64~ is ~eval~'d to get the resulting dictionary, so can itself contain richer logic to build up arguments.
***** As a self-contained shell script
#+begin_src bash
# example/echo/echo_script.sh

URL="$1"
read -r -d '' CODE << EOF
def run(name: str):
  return f'Hello, {name}!'
EOF
curl --json $(jo \
  code_b64=$(echo "$CODE" | base64 -w 0) \
  kwargs_b64=$(echo "{'name': 'owt'}" | base64 -w 0) \
) $URL/hello
#+end_src

#+begin_src bash :exports both :results output replace
./example/echo/echo_script.sh http://localhost:9876
#+end_src

#+results: 
: Hello, owt!
***** As a Python file + script
#+begin_src python
# example/echo/echo.py

from owt import Server


def run(name=None):
    return f"Hello, {name}, from {Server.sing().address}:{Server.sing().port}!"
#+end_src

Passing data via POST JSON ~kwargs~:

#+begin_src bash
# example/echo/echo_kwargs.sh

URL="$1"
CODE_B64=$(cat example/echo/echo.py | base64 -w 0)
KWARGS_B64=$(echo "{'name': 'owt'}" | base64 -w 0)
curl --json $(jo code_b64=$CODE_B64 kwargs_b64=$KWARGS_B64) $URL/hello
#+end_src

#+begin_src bash :exports both :results output replace
./example/echo/echo_kwargs.sh http://localhost:9876
#+end_src

#+results: 
: Hello, owt, from 0.0.0.0:9876!


Passing data via GET in the path:

#+begin_src bash
# example/echo/echo_request.sh

URL="$1"
CODE_B64=$(cat example/echo/echo.py | base64 -w 0)
KWARGS_B64=$(echo "{'name': 'owt'}" | base64 -w 0)
curl -G --data-urlencode code_b64=$CODE_B64 --data-urlencode kwargs_b64=$KWARGS_B64 $URL
#+end_src

#+begin_src bash :exports both :results output replace
./example/echo/echo_request.sh http://localhost:9876
#+end_src

#+results: 
: Hello, owt, from 0.0.0.0:9876!
**** Text to Speech API
A more complex example demonstrating wrapping Suno's OSS TTS model [[https://github.com/suno-ai/bark]].

The client provides an adaptor that responds with a stream of bytes, allowing the generated audio to be streamed in chunks, sentence-by-sentence.

Responses are cached for the lifetime of the ~owt~ server for each combination of ~(text, speaker)~.

The ~preload_models()~ call makes the first call take a while as VRAM is populated, but the weights remain in memory so subsequent calls are cheaper.

To avoid this breaking other ~owt~ uses, one can spin up multiple instances of ~owt~, each handling a different kind of task and with different resource profiles.
***** Python Adaptor
The endpoint logic, to be base64-encoded as part of the request.
#+begin_src python
# example/bark/bark.py
from typing import Literal

def run(request,
        text: str,
        speaker: str = "v2/en_speaker_6",
        sentence_template: str = "%s",
        split_type: Literal["sentence", "none"] = "sentence"):

    import os
    import logging
    import json
    import io
    import nltk
    import numpy as np
    import base64
    from scipy.io.wavfile import write as write_wav

    os.environ["CUDA_VISIBLE_DEVICES"] = "0"
    os.environ["SUNO_USE_SMALL_MODELS"] = "0"
    os.environ["SUNO_OFFLOAD_CPU"] = "0"

    from bark.generation import generate_text_semantic, preload_models, SAMPLE_RATE
    from bark.api import semantic_to_waveform

    preload_models()

    def base64_wav(arr):
        buf = io.BytesIO()
        write_wav(buf, SAMPLE_RATE, arr)
        wav = buf.getvalue()
        return base64.b64encode(wav).decode("utf-8")

    def generate():
        clean_text = text.replace("\n", " ").strip()
        match split_type:
            case "sentence":
                sentences = nltk.sent_tokenize(clean_text)
            case "none":
                sentences = [clean_text]
        full_wav_array = None
        for i, raw_sentence in enumerate(sentences):
            sentence = sentence_template % raw_sentence
            logging.info(
                "Generating sentence %d/%d: %s", i + 1, len(sentences), sentence
            )
            semantic_tokens = generate_text_semantic(
                sentence,
                history_prompt=speaker,
                temp=0.6,
                min_eos_p=0.05,
            )
            wav_array = semantic_to_waveform(semantic_tokens, history_prompt=speaker)
            full_wav_array = (
                wav_array
                if full_wav_array is None
                else np.concatenate((full_wav_array, wav_array))
            )

            yield "data: %s\n\n" % (
                json.dumps(
                    {
                        "sentence": base64_wav(wav_array),
                        "cumulative": base64_wav(full_wav_array),
                    }
                )
            )
        yield "data: DONE\n\n"

    return generate(), {"Content-Type": "text/event-stream"}
#+end_src
***** Save audio via cURL
Bundle the endpoint logic with a prompt and download the resulting audio.
#+begin_src bash
# example/bark/bark.sh
#
# Usage:
# ./example/bark/bark.sh http://localhost:9876/file.wav "Hello world! This is a test." /tmp/output_dir

URL="$1"
TEXT="$2"
OUTDIR="$3"

CODE_B64="$(cat example/bark/bark.py | base64 -w 0)"
KWARGS_B64=$(echo "{\"text\": \"$TEXT\"}" | base64 -w 0)
JSON=$(jo \
  code_b64=$CODE_B64 \
  kwargs_b64=$KWARGS_B64 \
  use_cache="true" \
  cache_kwargs="true" \
)
CMD="curl --json $JSON $URL"

echo "Running $CMD"
I=0
for event in "$($CMD)"; do
  if [[ "$event" == "data: {"* ]]; then
    WAV="$(echo -n "$event" | sed 's/data: //g' | jq '.sentence' | base64 -d)"
    echo "$WAV" > "$OUTDIR/sentence$I.wav"
    I=$((I+1))
  fi
done
#+end_src
***** Stream audio via JS
Use an endpoint from a webapp - see ~example/bark/bark.html~ for usage.
#+begin_src javascript
function makeRequest(code, text, speaker, sentenceTemplate, splitType) {
  return {
    'code_b64': btoa(code),
    'kwargs_b64': btoa(JSON.stringify({
      'text': text.replace(/\n/g, '\\n'),
      'speaker': speaker,
      'sentence_template': sentenceTemplate,
      'split_type': splitType
    })),
  };
}

function audioUrl(
  url, code, text, speaker, sentenceTemplate, splitType) {
  const request = makeRequest(
    code, text, speaker, sentenceTemplate, splitType);
  return url + '?' + $.param(request);
}

async function getAudio(
  url, code, text, speaker, sentenceTemplate, splitType, onChunk) {
  const source = new EventSource(
    audioUrl(url, code, text, speaker, sentenceTemplate, splitType));
  source.onmessage = function(event) {
    if (event.data.toLowerCase() == 'done') {
      source.close();
      return;
    }
    const chunk = JSON.parse(event.data);
    onChunk(chunk);
  }
}
#+end_src
***** Ad-hoc Web Server
In fact we can go one step further now and bootstrap our own webserver within ~owt~ to serve our prototype app.

We ca create an adhoc endpoint that serves us the rendered ~bark.html~ Jinja2 template.

The ~owt~ arguments can be passed as GET query parameters as well as POST JSON data, so we can actually write a handler that embeds the entire HTML into the query with this Python-in-Python-in-Bash curiosity.

#+begin_src bash
# example/bark/bark_construct_curl.sh

URL="$1"
CODE=$(python <<EOF
with open('example/bark/bark.html', 'r') as html_f:
  html = html_f.read()
  with open('example/bark/bark.py', 'r') as code_f:
    code = code_f.read()
    with open('example/bark/bark.js', 'r') as js_f:
      template = (html.replace('{% include "bark.py" %}', code)
                  .replace('<script src="/bark/bark.js"></script>',
                           '<script>\n'+js_f.read()+'\n</script>'))
      print('''
def run(_):
  return (r\'\'\'
'''+template+'''
\'\'\')''')
EOF
)
CODE_B64=$(base64 -w 0 <<< "$CODE")
echo "curl -G --data-urlencode \"code_b64=$CODE_B64\" $URL"
#+end_src

#+begin_src bash :exports both :results output replace
bash -c "$(./example/bark/bark_construct_curl.sh http://localhost:9876) -s -o /dev/null -w '%{url}'"
#+end_src

#+results: 
: http://localhost:9876/?code_b64=CmRlZiBydW4oXyk6CiAgcmV0dXJuIChyJycnCjwhZG9jdHlwZSBodG1sPgo8aHRtbD4KICA8aGVhZD4KICAgIDx0aXRsZT5iYXJrIHRlc3Q8L3RpdGxlPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2Nkbi5zaW1wbGVjc3Mub3JnL3NpbXBsZS5taW4uY3NzIj4KICAgIDxzY3JpcHQ%2bCmZ1bmN0aW9uIG1ha2VSZXF1ZXN0KGNvZGUsIHRleHQsIHNwZWFrZXIsIHNlbnRlbmNlVGVtcGxhdGUsIHNwbGl0VHlwZSkgewogIHJldHVybiB7CiAgICAnY29kZV9iNjQnOiBidG9hKGNvZGUpLAogICAgJ2t3YXJnc19iNjQnOiBidG9hKEpTT04uc3RyaW5naWZ5KHsKICAgICAgJ3RleHQnOiB0ZXh0LnJlcGxhY2UoL1xuL2csICdcXG4nKSwKICAgICAgJ3NwZWFrZXInOiBzcGVha2VyLAogICAgICAnc2VudGVuY2VfdGVtcGxhdGUnOiBzZW50ZW5jZVRlbXBsYXRlLAogICAgICAnc3BsaXRfdHlwZSc6IHNwbGl0VHlwZQogICAgfSkpLAogIH07Cn0KCmZ1bmN0aW9uIGF1ZGlvVXJsKAogIHVybCwgY29kZSwgdGV4dCwgc3BlYWtlciwgc2VudGVuY2VUZW1wbGF0ZSwgc3BsaXRUeXBlKSB7CiAgY29uc3QgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KAogICAgY29kZSwgdGV4dCwgc3BlYWtlciwgc2VudGVuY2VUZW1wbGF0ZSwgc3BsaXRUeXBlKTsKICByZXR1cm4gdXJsICsgJz8nICsgJC5wYXJhbShyZXF1ZXN0KTsKfQoKYXN5bmMgZnVuY3Rpb24gZ2V0QXVkaW8oCiAgdXJsLCBjb2RlLCB0ZXh0LCBzcGVha2VyLCBzZW50ZW5jZVRlbXBsYXRlLCBzcGxpdFR5cGUsIG9uQ2h1bmspIHsKICBjb25zdCBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoCiAgICBhdWRpb1VybCh1cmwsIGNvZGUsIHRleHQsIHNwZWFrZXIsIHNlbnRlbmNlVGVtcGxhdGUsIHNwbGl0VHlwZSkpOwogIHNvdXJjZS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkgewogICAgaWYgKGV2ZW50LmRhdGEudG9Mb3dlckNhc2UoKSA9PSAnZG9uZScpIHsKICAgICAgc291cmNlLmNsb3NlKCk7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGNvbnN0IGNodW5rID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTsKICAgIG9uQ2h1bmsoY2h1bmspOwogIH0KfQoKPC9zY3JpcHQ%2bCiAgICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly9jb2RlLmpxdWVyeS5jb20vanF1ZXJ5LTMuNy4xLmpzIiBpbnRlZ3JpdHk9InNoYTI1Ni1lS2hheWk4TEVRd3A0Tkt4TitDZkNoKzNxT1ZVdEpuM1FOWjBUY2lXTFA0PSIgY3Jvc3NvcmlnaW49ImFub255bW91cyI%2bPC9zY3JpcHQ%2bCiAgICA8c2NyaXB0PgoKICAgICAgZnVuY3Rpb24gYXVkaW9DaHVua0hhbmRsZXIoY2h1bmspIHsKICAgICAgICBjb25zb2xlLmxvZygnYXVkaW8gY2h1bmsnLCBjaHVuayk7CiAgICAgICAgd2F2QjY0ID0gY2h1bmtbJ2N1bXVsYXRpdmUnXTsKICAgICAgICBjb25zb2xlLmxvZygnYXVkaW8gY2h1bmsgYjY0Jywgd2F2QjY0KTsKICAgICAgICB3YXZEYXRhID0gVWludDhBcnJheS5mcm9tKGF0b2Iod2F2QjY0KSwgYyA9PiBjLmNoYXJDb2RlQXQoMCkpCiAgICAgICAgY29uc29sZS5sb2coJ2F1ZGlvIGNodW5rIGRhdGEnLCB3YXZEYXRhKTsKICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW3dhdkRhdGFdLCB7IHR5cGU6ICdhdWRpby93YXYnIH0pOwogICAgICAgIHNldEF1ZGlvRGF0YVVSTChibG9iKTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gaGFuZGxlU3BlYWsoKSB7CiAgICAgICAgcmV0dXJuIGdldEF1ZGlvKAogICAgICAgICAgICAkKCIjdXJsIikudmFsKCksCiAgICAgICAgICAgICQoIiNjb2RlIikudGV4dCgpLAogICAgICAgICAgICAkKCcjYmFyay1pbnB1dCcpLnZhbCgpLAogICAgICAgICAgICAkKCIjc3BlYWtlciIpLnZhbCgpLAogICAgICAgICAgICAkKCIjc2VudGVuY2UtdGVtcGxhdGUiKS52YWwoKSwKICAgICAgICAgICAgJCgiI3NwbGl0LXR5cGUiKS52YWwoKSwKICAgICAgICAgICAgYXVkaW9DaHVua0hhbmRsZXIKICAgICAgICApOwogICAgICB9CgogICAgICBjb25zdCBhdWRpbyA9IG5ldyBBdWRpbygpOwoKICAgICAgZnVuY3Rpb24gbWFrZUF1ZGlvKGJsb2IpIHsKICAgICAgICBjb25zdCB0aW1lID0gYXVkaW8uY3VycmVudFRpbWUgfHwgYXVkaW8uZHVyYXRpb247CiAgICAgICAgYXVkaW8uc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTsKICAgICAgICBhdWRpby5jb250cm9scyA9IHRydWU7CiAgICAgICAgYXVkaW8ucGxheSgpLnRoZW4oKCkgPT4gewogICAgICAgICAgaWYgKHRpbWUpIHsKICAgICAgICAgICAgYXVkaW8uY3VycmVudFRpbWUgPSB0aW1lOwogICAgICAgICAgfQogICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4gewogICAgICAgICAgY29uc29sZS5lcnJvcignYXVkaW8gcGxheSBlcnJvcicsIGVycm9yKTsKICAgICAgICB9KTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gc2V0QXVkaW9EYXRhVVJMKGJsb2IpIHsKICAgICAgICBjb25zb2xlLmxvZygnc2V0dGluZyBhdWRpbyBkYXRhIHVybCcsIGJsb2IpOwogICAgICAgIG1ha2VBdWRpbyhibG9iKTsKICAgICAgfQoKICAgICAgJChmdW5jdGlvbigpIHsKICAgICAgICAgIGNvbnN0IGF1ZGlvRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Jhcmstb3V0cHV0Jyk7CiAgICAgICAgICBhdWRpb0Rpdi5yZXBsYWNlQ2hpbGRyZW4oYXVkaW8pOwogICAgICB9KTsKICAgIDwvc2NyaXB0PgogIDwvaGVhZD4KICA8Ym9keT4KICAgIDxsYWJlbCBmb3I9InVybCI%2bRXhlYyBVUkw8L2xhYmVsPgogICAgPGlucHV0IHR5cGU9InRleHQiIGlkPSJ1cmwiIHZhbHVlPSJodHRwOi8vbG9jYWxob3N0Ojk4NzYiPjwvaW5wdXQ%2bCiAgICA8bGFiZWwgZm9yPSJiYXJrLWlucHV0Ij5UZXh0IHRvIHNwZWFrPC9sYWJlbD4KICAgIDx0ZXh0YXJlYSBpZD0iYmFyay1pbnB1dCI%2bSXQgd2FzIGEgYnJpZ2h0IGNvbGQgZGF5IGluIEFwcmlsLCBhbmQgdGhlIGNsb2NrcyB3ZXJlIHN0cmlraW5nIHRoaXJ0ZWVuLiBXaW5zdG9uIFNtaXRoLCBoaXMgY2hpbiBudXp6bGVkIGludG8gaGlzIGJyZWFzdCBpbiBhbiBlZmZvcnQgdG8gZXNjYXBlIHRoZSB2aWxlIHdpbmQsIHNsaXBwZWQgcXVpY2tseSB0aHJvdWdoIHRoZSBnbGFzcyBkb29ycyBvZiBWaWN0b3J5IE1hbnNpb25zLCB0aG91Z2ggbm90IHF1aWNrbHkgZW5vdWdoIHRvIHByZXZlbnQgYSBzd2lybCBvZiBncml0dHkgZHVzdCBmcm9tIGVudGVyaW5nIGFsb25nIHdpdGggaGltLiBUaGUgaGFsbHdheSBzbWVsdCBvZiBib2lsZWQgY2FiYmFnZSBhbmQgb2xkIHJhZyBtYXRzLiBBdCBvbmUgZW5kIG9mIGl0IGEgY29sb3VyZWQgcG9zdGVyLCB0b28gbGFyZ2UgZm9yIGluZG9vciBkaXNwbGF5LCBoYWQgYmVlbiB0YWNrZWQgdG8gdGhlIHdhbGwuIEl0IGRlcGljdGVkIHNpbXBseSBhbiBlbm9ybW91cyBmYWNlLCBtb3JlIHRoYW4gYSBtZXRyZSB3aWRlOiB0aGUgZmFjZSBvZiBhIG1hbiBvZiBhYm91dCBmb3J0eS1maXZlLCB3aXRoIGEgaGVhdnkgYmxhY2sgbW91c3RhY2hlIGFuZCBydWdnZWRseSBoYW5kc29tZSBmZWF0dXJlcy4gV2luc3RvbiBtYWRlIGZvciB0aGUgc3RhaXJzLiBJdCB3YXMgbm8gdXNlIHRyeWluZyB0aGUgbGlmdC4gRXZlbiBhdCB0aGUgYmVzdCBvZiB0aW1lcyBpdCB3YXMgc2VsZG9tIHdvcmtpbmcsIGFuZCBhdCBwcmVzZW50IHRoZSBlbGVjdHJpYyBjdXJyZW50IHdhcyBjdXQgb2ZmIGR1cmluZyBkYXlsaWdodCBob3Vycy4gSXQgd2FzIHBhcnQgb2YgdGhlIGVjb25vbXkgZHJpdmUgaW4gcHJlcGFyYXRpb24gZm9yIEhhdGVXZWVrLiBUaGUgZmxhdCB3YXMgc2V2ZW4gZmxpZ2h0cyB1cCwgYW5kIFdpbnN0b24sIHdobyB3YXMgdGhpcnR5LW5pbmUgYW5kIGhhZCBhIHZhcmljb3NlIHVsY2VyIGFib3ZlIGhpcyByaWdodCBhbmtsZSwgd2VudCBzbG93bHksIHJlc3Rpbmcgc2V2ZXJhbCB0aW1lcyBvbiB0aGUgd2F5LiBPbiBlYWNoIGxhbmRpbmcsIG9wcG9zaXRlIHRoZSBsaWZ0IHNoYWZ0LCB0aGUgcG9zdGVyIHdpdGggdGhlIGVub3Jtb3VzIGZhY2UgZ2F6ZWQgZnJvbSB0aGUgd2FsbC4gSXQgd2FzIG9uZSBvZiB0aG9zZSBwaWN0dXJlcyB3aGljaCBhcmUgc28gY29udHJpdmVkIHRoYXQgdGhlIGV5ZXMgZm9sbG93IHlvdSBhYm91dCB3aGVuIHlvdSBtb3ZlLiBCSUcgQlJPVEhFUiBJUyBXQVRDSElORyBZT1UsIHRoZSBjYXB0aW9uIGJlbmVhdGggaXQgcmFuLjwvdGV4dGFyZWE%2bCiAgICA8bGFiZWwgZm9yPSJzcGxpdC10eXBlIj5TcGxpdCBPbjo8L2xhYmVsPgogICAgPHNlbGVjdCBpZD0ic3BsaXQtdHlwZSI%2bCiAgICAgIDxvcHRpb24gdmFsdWU9InNlbnRlbmNlIj5TZW50ZW5jZTwvb3B0aW9uPgogICAgICA8b3B0aW9uIHZhbHVlPSJub25lIj5Ob25lPC9vcHRpb24%2bCiAgICA8L3NlbGVjdD4KICAgIDxsYWJlbCBmb3I9InNwZWFrZXIiPgogICAgPGEgaHJlZj0iaHR0cHM6Ly9zdW5vLWFpLm5vdGlvbi5zaXRlLzhiOGU4NzQ5ZWQ1MTRiMGNiZjNmNjk5MDEzNTQ4NjgzP3Y9YmM2N2NmZjc4NmIwNGI1MGIzY2ViNzU2ZmQwNWY2OGMiPlNwZWFrZXI8L2E%2bCiAgICA8L2xhYmVsPgogICAgPGlucHV0IHR5cGU9InRleHQiIGlkPSJzcGVha2VyIiB2YWx1ZT0idjIvZnJfc3BlYWtlcl8xIj48L2lucHV0PgogICAgPGxhYmVsIGZvcj0ic2VudGVuY2UtdGVtcGxhdGUiPlNlbnRlbmNlIFRlbXBsYXRlPC9sYWJlbD4KICAgIDxpbnB1dCB0eXBlPSJ0ZXh0IiBpZD0ic2VudGVuY2UtdGVtcGxhdGUiIHZhbHVlPSIlcyI%2bPC9pbnB1dD4KICAgIDxidXR0b24gb25jbGljaz0iaGFuZGxlU3BlYWsoKSI%2bU3BlYWs8L2J1dHRvbj4KICAgIDxkaXYgaWQ9ImJhcmstb3V0cHV0Ij48L2Rpdj4KICAgIDxwcmU%2bCiAgICAgIDxjb2RlIGlkPSJjb2RlIiBjb250ZW50ZWRpdGFibGU9InRydWUiPgojIGV4YW1wbGUvYmFyay9iYXJrLnB5CmZyb20gdHlwaW5nIGltcG9ydCBMaXRlcmFsCgpkZWYgcnVuKHJlcXVlc3QsCiAgICAgICAgdGV4dDogc3RyLAogICAgICAgIHNwZWFrZXI6IHN0ciA9ICJ2Mi9lbl9zcGVha2VyXzYiLAogICAgICAgIHNlbnRlbmNlX3RlbXBsYXRlOiBzdHIgPSAiJXMiLAogICAgICAgIHNwbGl0X3R5cGU6IExpdGVyYWxbInNlbnRlbmNlIiwgIm5vbmUiXSA9ICJzZW50ZW5jZSIpOgoKICAgIGltcG9ydCBvcwogICAgaW1wb3J0IGxvZ2dpbmcKICAgIGltcG9ydCBqc29uCiAgICBpbXBvcnQgaW8KICAgIGltcG9ydCBubHRrCiAgICBpbXBvcnQgbnVtcHkgYXMgbnAKICAgIGltcG9ydCBiYXNlNjQKICAgIGZyb20gc2NpcHkuaW8ud2F2ZmlsZSBpbXBvcnQgd3JpdGUgYXMgd3JpdGVfd2F2CgogICAgb3MuZW52aXJvblsiQ1VEQV9WSVNJQkxFX0RFVklDRVMiXSA9ICIwIgogICAgb3MuZW52aXJvblsiU1VOT19VU0VfU01BTExfTU9ERUxTIl0gPSAiMCIKICAgIG9zLmVudmlyb25bIlNVTk9fT0ZGTE9BRF9DUFUiXSA9ICIwIgoKICAgIGZyb20gYmFyay5nZW5lcmF0aW9uIGltcG9ydCBnZW5lcmF0ZV90ZXh0X3NlbWFudGljLCBwcmVsb2FkX21vZGVscywgU0FNUExFX1JBVEUKICAgIGZyb20gYmFyay5hcGkgaW1wb3J0IHNlbWFudGljX3RvX3dhdmVmb3JtCgogICAgcHJlbG9hZF9tb2RlbHMoKQoKICAgIGRlZiBiYXNlNjRfd2F2KGFycik6CiAgICAgICAgYnVmID0gaW8uQnl0ZXNJTygpCiAgICAgICAgd3JpdGVfd2F2KGJ1ZiwgU0FNUExFX1JBVEUsIGFycikKICAgICAgICB3YXYgPSBidWYuZ2V0dmFsdWUoKQogICAgICAgIHJldHVybiBiYXNlNjQuYjY0ZW5jb2RlKHdhdikuZGVjb2RlKCJ1dGYtOCIpCgogICAgZGVmIGdlbmVyYXRlKCk6CiAgICAgICAgY2xlYW5fdGV4dCA9IHRleHQucmVwbGFjZSgiXG4iLCAiICIpLnN0cmlwKCkKICAgICAgICBtYXRjaCBzcGxpdF90eXBlOgogICAgICAgICAgICBjYXNlICJzZW50ZW5jZSI6CiAgICAgICAgICAgICAgICBzZW50ZW5jZXMgPSBubHRrLnNlbnRfdG9rZW5pemUoY2xlYW5fdGV4dCkKICAgICAgICAgICAgY2FzZSAibm9uZSI6CiAgICAgICAgICAgICAgICBzZW50ZW5jZXMgPSBbY2xlYW5fdGV4dF0KICAgICAgICBmdWxsX3dhdl9hcnJheSA9IE5vbmUKICAgICAgICBmb3IgaSwgcmF3X3NlbnRlbmNlIGluIGVudW1lcmF0ZShzZW50ZW5jZXMpOgogICAgICAgICAgICBzZW50ZW5jZSA9IHNlbnRlbmNlX3RlbXBsYXRlICUgcmF3X3NlbnRlbmNlCiAgICAgICAgICAgIGxvZ2dpbmcuaW5mbygKICAgICAgICAgICAgICAgICJHZW5lcmF0aW5nIHNlbnRlbmNlICVkLyVkOiAlcyIsIGkgKyAxLCBsZW4oc2VudGVuY2VzKSwgc2VudGVuY2UKICAgICAgICAgICAgKQogICAgICAgICAgICBzZW1hbnRpY190b2tlbnMgPSBnZW5lcmF0ZV90ZXh0X3NlbWFudGljKAogICAgICAgICAgICAgICAgc2VudGVuY2UsCiAgICAgICAgICAgICAgICBoaXN0b3J5X3Byb21wdD1zcGVha2VyLAogICAgICAgICAgICAgICAgdGVtcD0wLjYsCiAgICAgICAgICAgICAgICBtaW5fZW9zX3A9MC4wNSwKICAgICAgICAgICAgKQogICAgICAgICAgICB3YXZfYXJyYXkgPSBzZW1hbnRpY190b193YXZlZm9ybShzZW1hbnRpY190b2tlbnMsIGhpc3RvcnlfcHJvbXB0PXNwZWFrZXIpCiAgICAgICAgICAgIGZ1bGxfd2F2X2FycmF5ID0gKAogICAgICAgICAgICAgICAgd2F2X2FycmF5CiAgICAgICAgICAgICAgICBpZiBmdWxsX3dhdl9hcnJheSBpcyBOb25lCiAgICAgICAgICAgICAgICBlbHNlIG5wLmNvbmNhdGVuYXRlKChmdWxsX3dhdl9hcnJheSwgd2F2X2FycmF5KSkKICAgICAgICAgICAgKQoKICAgICAgICAgICAgeWllbGQgImRhdGE6ICVzXG5cbiIgJSAoCiAgICAgICAgICAgICAgICBqc29uLmR1bXBzKAogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgInNlbnRlbmNlIjogYmFzZTY0X3dhdih3YXZfYXJyYXkpLAogICAgICAgICAgICAgICAgICAgICAgICAiY3VtdWxhdGl2ZSI6IGJhc2U2NF93YXYoZnVsbF93YXZfYXJyYXkpLAogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgKQogICAgICAgIHlpZWxkICJkYXRhOiBET05FXG5cbiIKCiAgICByZXR1cm4gZ2VuZXJhdGUoKSwgeyJDb250ZW50LVR5cGUiOiAidGV4dC9ldmVudC1zdHJlYW0ifQoKICAgICAgPC9jb2RlPgogICAgPC9wcmU%2bCiAgPC9ib2R5Pgo8L2h0bWw%2bCgonJycpCg%3d%3d


Whew. We can open that ~owt~ URL in a browser and play with the web app, which itself makes calls to ~owt~ injecting the TTS logic.
***** Going Meta

That gets painful though - for iterative development, you want to save your code and hit refresh. This won't do anything here, since all code is snapshotted into the URL itself. However...

#+begin_src bash
# example/bark/bark_meta_curl.sh

URL="$1"
read -r -d '' CODE << 'EOF'
def run(_, base_url):
  import os
  html = os.popen(f'bash -c "$(./example/bark/bark_construct_curl.sh {base_url})"').read()
  return html
EOF

KWARGS="{\"base_url\": \"$URL\"}"
CODE_B64=$(base64 -w 0 <<< "$CODE")
KWARGS_B64=$(base64 -w 0 <<< "$KWARGS")
echo "curl -G --data-urlencode code_b64=$CODE_B64 --data-urlencode kwargs_b64=$KWARGS_B64 $URL"
#+end_src

#+begin_src bash :exports both :results output replace
./example/bark/bark_meta_curl.sh http://localhost:9876
#+end_src

#+results: 
: curl -G --data-urlencode code_b64=ZGVmIHJ1bihfLCBiYXNlX3VybCk6CiAgaW1wb3J0IG9zCiAgaHRtbCA9IG9zLnBvcGVuKGYnYmFzaCAtYyAiJCguL2V4YW1wbGUvYmFyay9iYXJrX2NvbnN0cnVjdF9jdXJsLnNoIHtiYXNlX3VybH0pIicpLnJlYWQoKQogIHJldHVybiBodG1sCg== --data-urlencode kwargs_b64=eyJiYXNlX3VybCI6ICJodHRwOi8vbG9jYWxob3N0Ojk4NzYifQo= http://localhost:9876


Sweet - this will resolve to the meta-evaluator that always renders a fresh copy of the app each time.

#+begin_src bash :exports both :results output replace
bash -c "$(./example/bark/bark_meta_curl.sh http://localhost:9876) -s -o /dev/null -w '%{url}'"
#+end_src

#+results: 
: http://localhost:9876/?code_b64=ZGVmIHJ1bihfLCBiYXNlX3VybCk6CiAgaW1wb3J0IG9zCiAgaHRtbCA9IG9zLnBvcGVuKGYnYmFzaCAtYyAiJCguL2V4YW1wbGUvYmFyay9iYXJrX2NvbnN0cnVjdF9jdXJsLnNoIHtiYXNlX3VybH0pIicpLnJlYWQoKQogIHJldHVybiBodG1sCg%3d%3d&kwargs_b64=eyJiYXNlX3VybCI6ICJodHRwOi8vbG9jYWxob3N0Ojk4NzYifQo%3d
**** Going Meta-Circular

So what would stop you hosting the entirey of ~owt.py~ on... wait, no...

#+begin_src bash
# example/meta/bootstrap.sh

function owtInOwt() {
  URL="$1"
  PORT="$2"
  PAYLOAD_CODE_B64="$3"
  PAYLOAD_KWARGS_B64="$4"
  read -r -d '' CODE << EOF
def run(**kwargs):
  payload_code_b64 = kwargs['payload_code_b64']
  payload_kwargs_b64 = kwargs['payload_kwargs_b64']
  _globals = {'__name__': __name__+'_new',
              'new_port': args.port + 1}
  _locals = {}
  print('going one level down to port %s' % _globals['new_port'])

  exec('''
print('One level deeper, importing owt')
from owt import *
from multiprocessing import Process
args.port = new_port
server_thread = Process(target=main)
''', _globals, _locals)

  def kill():
    import time
    # time.sleep(1)
    print('Killing server on %s' % args.port)
    _locals['server_thread'].terminate()
    print('Killed server on %d' % args.port)

  from multiprocessing import Process
  from flask import request
  import requests
  import urllib

  _locals['server_thread'].start()
  bootstrapped_url = f"$URL:{_globals['new_port']}/{request.path}?code_b64={urllib.parse.quote_plus(payload_code_b64)}&kwargs_b64={urllib.parse.quote_plus(payload_kwargs_b64)}"
  print(bootstrapped_url)
  resp = requests.get(bootstrapped_url).content
  Process(target=kill).start()
  return resp
EOF

  CODE_B64=$(base64 -w 0 <<< "$CODE")
  KWARGS_B64=$(base64 -w 0 <<< "{\"payload_code_b64\":\"$PAYLOAD_CODE_B64\", \"payload_kwargs_b64\": \"$PAYLOAD_KWARGS_B64\"}")
  CMD="curl -G --data-urlencode code_b64=$CODE_B64 --data-urlencode kwargs_b64=$KWARGS_B64 $URL:$PORT"
  echo $CMD
}
#+end_src

Oh no, no...

#+begin_src bash :exports both :results output replace
source "example/meta/bootstrap.sh"

# Load up the nice simple echo example from earlier
CODE_B64=$(cat example/echo/echo.py | base64 -w 0)
KWARGS_B64=$(echo "{'name': 'owt-inside-owt'}" | base64 -w 0)

# Send a request that installs a full copy of owt and calls it with the payload code+kwargs
# Notice that the response comes from the inner server on 9877
CMD=$(owtInOwt http://localhost 9876 "$CODE_B64" "$KWARGS_B64")
echo "Running: $CMD"
echo "Result:"
bash -c "$CMD"
#+end_src

#+results: 
: Running: curl -G --data-urlencode code_b64=ZGVmIHJ1bigqKmt3YXJncyk6CiAgcGF5bG9hZF9jb2RlX2I2NCA9IGt3YXJnc1sncGF5bG9hZF9jb2RlX2I2NCddCiAgcGF5bG9hZF9rd2FyZ3NfYjY0ID0ga3dhcmdzWydwYXlsb2FkX2t3YXJnc19iNjQnXQogIF9nbG9iYWxzID0geydfX25hbWVfXyc6IF9fbmFtZV9fKydfbmV3JywKICAgICAgICAgICAgICAnbmV3X3BvcnQnOiBhcmdzLnBvcnQgKyAxfQogIF9sb2NhbHMgPSB7fQogIHByaW50KCdnb2luZyBvbmUgbGV2ZWwgZG93biB0byBwb3J0ICVzJyAlIF9nbG9iYWxzWyduZXdfcG9ydCddKQoKICBleGVjKCcnJwpwcmludCgnT25lIGxldmVsIGRlZXBlciwgaW1wb3J0aW5nIG93dCcpCmZyb20gb3d0IGltcG9ydCAqCmZyb20gbXVsdGlwcm9jZXNzaW5nIGltcG9ydCBQcm9jZXNzCmFyZ3MucG9ydCA9IG5ld19wb3J0CnNlcnZlcl90aHJlYWQgPSBQcm9jZXNzKHRhcmdldD1tYWluKQonJycsIF9nbG9iYWxzLCBfbG9jYWxzKQoKICBkZWYga2lsbCgpOgogICAgaW1wb3J0IHRpbWUKICAgICMgdGltZS5zbGVlcCgxKQogICAgcHJpbnQoJ0tpbGxpbmcgc2VydmVyIG9uICVzJyAlIGFyZ3MucG9ydCkKICAgIF9sb2NhbHNbJ3NlcnZlcl90aHJlYWQnXS50ZXJtaW5hdGUoKQogICAgcHJpbnQoJ0tpbGxlZCBzZXJ2ZXIgb24gJWQnICUgYXJncy5wb3J0KQoKICBmcm9tIG11bHRpcHJvY2Vzc2luZyBpbXBvcnQgUHJvY2VzcwogIGZyb20gZmxhc2sgaW1wb3J0IHJlcXVlc3QKICBpbXBvcnQgcmVxdWVzdHMKICBpbXBvcnQgdXJsbGliCgogIF9sb2NhbHNbJ3NlcnZlcl90aHJlYWQnXS5zdGFydCgpCiAgYm9vdHN0cmFwcGVkX3VybCA9IGYiaHR0cDovL2xvY2FsaG9zdDp7X2dsb2JhbHNbJ25ld19wb3J0J119L3tyZXF1ZXN0LnBhdGh9P2NvZGVfYjY0PXt1cmxsaWIucGFyc2UucXVvdGVfcGx1cyhwYXlsb2FkX2NvZGVfYjY0KX0ma3dhcmdzX2I2ND17dXJsbGliLnBhcnNlLnF1b3RlX3BsdXMocGF5bG9hZF9rd2FyZ3NfYjY0KX0iCiAgcHJpbnQoYm9vdHN0cmFwcGVkX3VybCkKICByZXNwID0gcmVxdWVzdHMuZ2V0KGJvb3RzdHJhcHBlZF91cmwpLmNvbnRlbnQKICBQcm9jZXNzKHRhcmdldD1raWxsKS5zdGFydCgpCiAgcmV0dXJuIHJlc3AK --data-urlencode kwargs_b64=eyJwYXlsb2FkX2NvZGVfYjY0IjoiSXlCbGVHRnRjR3hsTDJWamFHOHZaV05vYnk1d2VRb0tabkp2YlNCdmQzUWdhVzF3YjNKMElGTmxjblpsY2dvS0NtUmxaaUJ5ZFc0b2JtRnRaVDFPYjI1bEtUb0tJQ0FnSUhKbGRIVnliaUJtSWtobGJHeHZMQ0I3Ym1GdFpYMHNJR1p5YjIwZ2UxTmxjblpsY2k1emFXNW5LQ2t1WVdSa2NtVnpjMzA2ZTFObGNuWmxjaTV6YVc1bktDa3VjRzl5ZEgwaElnbz0iLCAicGF5bG9hZF9rd2FyZ3NfYjY0IjogImV5ZHVZVzFsSnpvZ0oyOTNkQzFwYm5OcFpHVXRiM2QwSjMwSyJ9Cg== http://localhost:9876
: Result:
: Hello, owt-inside-owt, from 0.0.0.0:9877!


Oh no... but that would mean you could... I wonder...

#+begin_src python
# example/bootstrap/bootstrap.py
from owt import args


def run(**kwargs):
    import os
    payload_code_b64 = kwargs["payload_code_b64"]
    payload_kwargs_b64 = kwargs["payload_kwargs_b64"]
    return os.popen(
        f'source ./example/meta/bootstrap.sh; $(owtInOwt http://localhost {args.port} "{payload_code_b64}" "{payload_kwargs_b64}")'
    ).read()
#+end_src

#+begin_src bash :exports both :results output replace
METACODE_B64=$(cat example/meta/bootstrap.py | base64 -w 0)
function wrapOwt() {
  CODE_B64="$1"
  KWARGS_B64="$2"
  METAKWARGS_B64=$(base64 -w 0 <<< "{\"payload_code_b64\":\"$CODE_B64\", \"payload_kwargs_b64\": \"$KWARGS_B64\"}")
  echo "$METAKWARGS_B64"
}

N_LAYERS=5
for layer in $(seq 1 $N_LAYERS); do
  CODE_B64=$(cat example/echo/echo.py | base64 -w 0)
  NAME="owt"
  for i in $(seq 1 $layer); do
      NAME="$NAME-inside-owt"
  done
  KWARGS_B64=$(echo "{\"name\": \"$NAME\"}" | base64 -w 0)
  METAKWARGS_B64=$(wrapOwt "$CODE_B64" "$KWARGS_B64")
  for i in $(seq 2 $layer); do
      METAKWARGS_B64=$(wrapOwt "$METACODE_B64" "$METAKWARGS_B64")
  done
  echo "layer: $NAME"
  CMD="curl -G --data-urlencode code_b64=$METACODE_B64 --data-urlencode kwargs_b64=$METAKWARGS_B64 http://localhost:9876"
  echo "Result: " $(bash -c "$CMD")
  sleep 1
done
#+end_src

#+results: 
#+begin_example
layer: owt-inside-owt
Result:  Hello, owt-inside-owt, from 0.0.0.0:9877!
layer: owt-inside-owt-inside-owt
Result:  Hello, owt-inside-owt-inside-owt, from 0.0.0.0:9878!
layer: owt-inside-owt-inside-owt-inside-owt
Result:  Hello, owt-inside-owt-inside-owt-inside-owt, from 0.0.0.0:9879!
layer: owt-inside-owt-inside-owt-inside-owt-inside-owt
Result:  Hello, owt-inside-owt-inside-owt-inside-owt-inside-owt, from 0.0.0.0:9880!
layer: owt-inside-owt-inside-owt-inside-owt-inside-owt-inside-owt
Result:  Hello, owt-inside-owt-inside-owt-inside-owt-inside-owt-inside-owt, from 0.0.0.0:9881!
#+end_example

Hoo boy. How is Python a real language.
** TODO 
- [ ] ~owt.summat~ building blocks for common operations
- [ ] Tiny client libraries
- [ ] Split into ~owt serve~ and ~owt encode some_file.py {arg:value}~
- [ ] Force-cache e.g. hit /favicon.ico in a way that responds with image bytes, and forces these image bytes for all future /favicon.ico GETs
